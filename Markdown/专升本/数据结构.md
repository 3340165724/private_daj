# 数据结构

## [一、绪论](#prolegomenon)

- #### 1、[基本概述](#Basic overview)

- #### 2、[数据类型](#data type)

- #### 3、[抽象数据类型](#Abstract data types)

- #### 4、[算法](#algorithm)

- #### 5、[时间复杂度](#Time complexity)

- #### 6、[空间复杂度](#Spatial complexity)

## [二、线性表](#Linear tables)

- #### 1、[线性表的概念](#The concept of linear tables)

- #### 2、[线性表的顺序表示](#Sequential representation of a linear table)

- #### 3、[线性表的链式表示](#A chain representation of a linear table)





## <a id="prolegomenon">一、绪论</a>

### 1、<a id="Basic overview">基本概述</a>

- 数据结构是一门研究<font color="red">非数值</font>计算程序设计中操作对象，以及这些对象之间的关系和操作的学科

#### 1）数据：对客观事物的符号表示。指所有能输入到计算机中并能够被计算机程序处理的符号的总称。

#### 2）数据元素：是数据的<font color="red">基本单位</font>，称为结点或记录。（<font color="red">二维表的一整行</font>）

#### 3）数据项：是数据处理中的<font color="red">最小单位</font>。是数据记录中最基本、不可分的数据单位。（<font color="red">二维表的一个单元格</font>）

#### 4）数据对象：性质相同的数据元素的集合，是数据的一个子集。（<font color="red">一张表</font>）

- 补充：四者之间的联系
  - 数据项 <  数据元素  <  数据对象  <  数据

#### 5）数据结构：

##### （1）定义：相互之间存在一种或多种<font color="red">特定关系</font>的数据元素的集合。（<font color="red">数据元素 + 关系</font>）

##### （2）数据结构的三要素：

- 逻辑结构
- 存储（物理）结构

- 对数据的运算：增、删、改、查、排

#### 6）数据的逻辑结构

##### （1）定义：描述数据元素之间的<font color="red">逻辑关系</font>，与数据的存储无关，独立于计算机

##### （2）分类

- 逻辑结构
  - 线性结构
  - 非线性结构
    - 树型
    - 集合
    - 图

##### （3）线性结构：数据结构之间存在线性关系（结构中的数据元素之间存在<font color="red">一对一</font>的关系）

##### （4）非线性结构

- 集合：结构中的数据元素除了同属于一种类型外，别无其它关系
- 树形结构：结构中的数据元素之间存在<font color="red">一对多</font>的关系
- 图形结构：结构中的数据元素之间存在<font color="red">多对多</font>的关系

#### 7）数据的存储结构（<font color="red">和计算机的存储有关，依赖于计算机</font>）

##### （1）定义：<font color="red">存储结构</font>又称为<font color="red">物理结构</font>，是数据结构<font color="red">在计算机中的实际表示方式</font>，它包括对数据元素的表示和对关系的表示。通常有四种基本的存储方法实现

##### （2）分类

- 存储（物理）结构
  - 顺序存储
  - 链式存储
  - 索引存储
  - 散列存储

##### （3）顺序存储：数据元素顺序存放，每个存储结点只含一个元素。结点之间的逻辑关系由存储单元的相邻位置来体现。通常借助<font color="red">程序设计语言的数组类型来描述</font>，其<font color="red">优点是存储密度大，可实现随机存取</font>。

##### （4）链式存储：不要求逻辑上相邻的结点在存储位置上相邻，结点之间的逻辑关系是由附加的结点指针来反映。

##### （5）索引存储：索引存储方法在存储结点信息时除建立存储结点信息外，还建立附加的索引表来表示节点地址。索引项的一般形式是<关键字， 地址>。关键字标识唯一一个结点，地址作为指向结点的指针。

##### （6）散列存储：根据结点的关键字通过散列函数直接计算出该结点的存储地址，这种存储方法本质上是顺序存储方法的扩展。



<br>

### 2、<a id="data type">数据类型</a>

- 数据类型是一个值的集合和定义在这个值集上的一组操作的总称 



<br>

### 3、<a id="Abstract data types">抽象数据类型（ADT）</a>

#### 1）定义：抽象就是抽取出实际问题的本质。抽象数据类型一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。（是数据对象，对象上的关系，和对象的基本操作封装在一起的一种表达方式）

#### 2）包含：数据对象集D，数据关系集S，基本操作集P

#### 3）三元组表示法：ADT =（D, S, P）

#### 4）抽象数据类型的定义格式

ADT抽象数据类型名{

数据对象D：<数据对象的定义>

数据关系S：<数据关系的定义>

基本操作P：<基本操作的定义>

}ADT抽象数据名

<br>

### 4、<a id="algorithm">算法</a>

#### 1）算法的定义：算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每条指令表示一个或多个操作（<font color="red">解决问题的方法和步骤</font>）

#### 2）程序的定义：用某种程序设计语言对算法进行具体实现

#### 3）算法和程序的关系：<font color="red">程序 = 数据结构  +  算法</font>

- 注意：算法不是程序

#### 4）算法的特性

- 有穷性：也称有限性。一个算法必须保证执行有限步之后结束且每一步都必须在有限时间内完成
- 确定性：每一步骤必须有确定的定义，不会产生二义性
- 可行性（可执行）：所有操作都必须可以通过已经实现的基本操作进行运算，并在有限次内实现，而且人们用纸和笔做有限次运算也可以完成
- 输入性：有 0 个或多个输入，以刻画运算的初始情况。0 个输入是指算法本身确定了初始条件
- 输出性：有一个或多个输出，以反映对输入数据加工后的结果

#### 5）算法设计的基本要求

- 正确性：要求算法能够正确地执行预先规定的功能和性质要求，这是最重要也是最基本的标准

- 可读性：易于让人理解

- 健壮性：有很好的容错性，能够对不合理的数据进行检查

- 高效性：效率主要是指算法的执行时间。同一个问题如果有多种算法可求解，执行时间短的算法效率高（执行时间短———时间复杂度）

- 低存储量：存储量是指算法执行过程中所需要的最大量存储空间（内存空间少———空间复杂度）

  补充：高效性与低存储量同时体现了算法的高效率

#### 6）衡量算法的方法有两类

- 事后统计：需要先将算法实现，然后在测量其时间和空间的开销，会有缺陷，所以一般采用事前分析估算法。
- 事前分析估算法：

#### 7）补充

- 同一算法，实现语言的级别越高，执行的效率就越低

<br>

### 5、<a id="Time complexity">时间复杂度</a>

- 所谓的时间复杂度是指最坏情况下，估算算法执行时间的一个上界

#### 1）问题规模：问题规模是算法求解问题输入量的多少，是问题大小本质的表示一般用整数 n 表示，<font color="red">问题规模是影响时间复杂度的主要因素</font>。

#### 2）语句频度：一条语句<font color="red">重复执行的次数</font>称作为语句频度。

#### 3）定义：看算法的执行次数随 n 增长而呈现哪种函数增长，则该函数就是时间复杂度

#### 4）算法的时间复杂度取决于<font color="red">问题规模</font>和<font color="red"> 待处理数据的初态</font>

#### 5）常见的渐进时间复杂度

#### O<sub>(1)</sub>	<	O<sub>(log<sub>2</sub>n)</sub>	<	O<sub>(n)</sub>	<	O<sub>(nlog<sub>2</sub>n)</sub>	<	O<sub>(n<sup>2</sup>)</sub>	<	O<sub>(n<sup>3</sup>)</sub>	<	O<sub>(2<sup>n</sup>)</sub>	<	O<sub>(n!)</sub>	<	O<sub>(n<sup>n</sup>)</sub>

#### 常数阶 	 对数阶		 线性阶      线性对数阶	  平方阶	

- 注意：算法的时间复杂度不仅依赖于问题的规模，也取决于输入数据的性质（如输入数据元素的初始状态）
- 时间复杂度越大，性能越差，随 n 的增长最快

#### 6）时间复杂度题型及解法

##### （1）题型一：求最优时间复杂度

- 方法：找最小的时间复杂度

  - 例如：以下各阶时间复杂度中，性能最优的是（B）

    A. O<sub>(nlog<sub>2</sub>n)</sub>	B. O<sub>(1)</sub>	c. O<sub>(n<sup>n</sup>)</sub>	D. O<sub>(2<sup>n</sup>)</sub>

##### （2）题型二：函数型时间复杂度

- 方法：
  - 找最大项（随 n 增长而增长最快的项）
  - 将系数变为1
    - 例如：f<sub>(n)</sub>  =  2n<sup>3</sup>  +  4n<sup>2</sup>  +  100 的时间复杂度为 O<sub>(n<sup>3</sup>)</sub>
    - f<sub>(n)</sub>   =  1000 的时间复杂度为 O<sub>(1)</sub>
    - f<sub>(n)</sub>  =  n<sup>2</sup>  + 200n 的时间复杂度为 O<sub>(n<sup>2</sup>)</sub>
    - f<sub>(n)</sub>  =  3n<sup>3</sup>  +  100n<sup>2</sup>  +  n  +  1 的时间复杂度为 O<sub>(n<sup>3</sup>)</sub>

##### （3）题型三：带循环的时间复杂度

- 循环：重复做某事

  - for循环

    ```
    for (初始值; 循环条件; 更新循环变量) {
    	循环体;
    }
    ```

  - while循环

    ```
    while (循环条件) {
    	循环体;
    }
    
    
    while循环的特点：
    1、先判断，在执行循环体
    2、如果不满足条件，可能一次循环体都不会执行
    3、执行一次循环之后要更新循环变量，不然会出现循环体
    ```
  
  - do-while循环
  
    ```
    do {
    	循环体;
    } while (循环条件);
    
    
    do-while循环的特点：
    1、先执行一次循环体，后再判断
    2、do-while循环最少都会执行一次
    3、执行一次循环之后要更新循环变量，不然会出现循环体
    4、在 do-while中，while (循环条件)之后要加 " ; "
    ```
    
  
- 带循环的时间复杂度方法：

  - 找影响循环执行次数的变量

  - 看变量的增长方式：

    - 程序执行次数和变量的增长无关 ------> O<sub>(1)</sub>

      - 例1：{++x; s=0}------> O<sub>(1)</sub>

      - ```
        for (i = 0; i < 2022; i++) {
        	s=i
        }
        
        执行次数和问题规模 n 无关，所以是常数阶时间复杂度： O(1)
        ```

    - i ++  ------> O<sub>(n)</sub>

      ```
      for (i = 1; i <= n; ++i) {
      	++x;
      	s += x;
      }
      
      时间复杂度为：O(n)
      ```

      

    - i *= 2  ------> O<sub>(log<sub>2</sub>n)</sub>

    - i *= 3  ------> O<sub>(log<sub>3</sub>n)</sub>
    
      ```
      int num1, num2;
      for (i = 0; i < n; i++){
      	num1 += 1;
      	for (j = 1; j <= n; j *= 2 ){
      		num2 += num1
      	}
      }
      
      时间复杂度为： O(n log2^n)
      ```
    
      
    
    - 两层循环嵌套（<font color="red">O<sub>(内)</sub> * O<sub>(外)</sub></font>）  ------> O<sub>(n<sup>2</sup>)</sub>
    
      ```
      for (i = 1; i <= n; ++i){
      	for (j = 1; j <= n; ++j){
      		++x;
      		s += x;
      	}
      }
      
      时间复杂度为： O(n^2)
      ```

<br>

### 6、<a id="Spatial complexity">空间复杂度</a>

- 该算法所耗费的存储空间。一个程序除了需要存储空间来存放本身所用数据外，也需要一些对数据进行操作的工作单元和存储一些为计算所需要的辅助空间。

##### 1）算法原地工作：

- 是指算法所需要辅助空间是常量，即O<sub>(1)</sub>	。
- <font color="red">该算法所需要辅助空间固定</font>





<br>

---

<br>

## <a id="Linear tables">二、线性表</a>

### 1、<a id="The concept of linear tables">线性表的概念</a>

#### 1）定义：线性表是具有<font color="red">相同数据类型</font>的 n（n >= 0）个数据元素的有限序列，通常记为（a<sub>1</sub> ,  a<sub>2</sub> , .....  a<sub>i</sub> , a<sub>i+1</sub> , .....a<sub>n</sub>），其中 n 为表长（表中元素个数），n=0时称为空表，a<sub>1</sub>为第一元素，又叫做表头，a<sub>n</sub>为最后一个元素，又叫表尾。

#### 2）线性表的逻辑特征

- 线性表有唯一的前驱和后继
- 第一个元素有且仅有一个后继，无前驱
- 最后一个元素有且仅有一个前驱，无后继

#### 3）线性表的存储结构

- **顺序存储结构**：简称为顺序表
- **链式存储结构**：简称为链表



<br>



### 2、<a id="Sequential representation of a linear table">线性表的顺序表示</a>

#### 1）定义：顺序表就是把线性表中的所有元素<font color="red">按照其逻辑顺序</font>，依次存储到指定的存储位置开始的一块<font color="red">连续</font>的存储空间中。借助数组实现。

#### 2）数组

- **数组简介**：具有相同数据类型的一组数据的集合

- **数组的特点**：

  - 具有相同数据类型
  - 在内存中连续分布（地址连续）
  - 空间需预先分配，分配好后大小固定不变
    - 随机存取特性-----》时间复杂度为 O<sub>(1)</sub>
  - 数组的编号叫下标，下表从0开始

- **数组的分类**

  - 按照数据类型
    - 整型数组
    - 浮点型数组
    - 字符型数组
    - 字符串型数组
  - 按照维数
    - 一维数组
    - 二维数组
    - 交错数组

- **数组的使用（以 Java 为例）**

  | 功能             | 语法                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | 声明数组         | 数据类型[] 数组名;                                           |
  | 声明并创建       | 数据类型[] 数组名 = new 数据类型[数组长度];                  |
  | 声明创建并初始化 | 1、数据类型[] 数组名 = new 数据类型[] {值1，值2，值3 ，.....，值n }<br />2、数据类型[] 数组名 = {值1，值2，值3 ，.....，值n} |

- **数组下标**

  - 提取数组长度时

    - 字符串： 数组名.length()；

    - 其他： 数组名.length；

- **数组排序**：Arrays.sort(数组名);

  - 注意：默认升序排序（从小到大）

#### 3）线性表

- **顺序表中元素的特点**：
  - 逻辑上相邻的数据元素，其物理次序（存储位置）也是相邻的。
  - 元素之间的逻辑关系通过<font color="red">相邻位置</font>来体现。
- **顺序表中第 i 个元素的存储地址**：LOC<sub>(a<sub> i</sub>)</sub> = LOC<sub>(a<sub> 1</sub>)</sub> + (i - 1) * C
  - 默认求出第一个存储单元的地址
  - 最后一个存储单元地址 = 存储单元地址 +（C - 1）   
  - LOC<sub>(a<sub> 1</sub>)</sub> :第一个元素地址
  - C：每个元素的存储空间
- 注意：在顺序表中，找到任何一个元素所花费的时间相同

#### 4）顺序表的基本操作

- **取值：**取值操作时根据指定的位置序号 i ，获取顺序表中第 i 个数据元素的值。时间复杂度为O<sub>(1)</sub> 。
  - 方法：由于顺序存储结构具有随机存取的特点，可以直接通过数组下标定位得到
  - 例如：elem[i - 1]单元存储第 i 个数据元素
- **插入：**在 n 个元素的顺序表中第 i（i <= n）个位置插入一个结点。其时间复杂度为 O<sub>(n)</sub>。
  - 方法：运算需要将从 a<sub>n</sub>到a<sub>i</sub> 。共 n - i + 1个元素向下移动一个位置
    - 元素后移：把位置 j 的元素移动到位置 j + 1（赋值实现，位置 j + 1 = 位置 j 的元素）
    - 插入元素：把元素 x 插入到第 i 个位置（赋值实现，第 i 个位置 = 元素 x）
  - 补充：顺序表中<font color="red">任意位置**插入**一个元素</font>的操作，<font color="red">平均移动元素次数为 **n / 2**</font>
- **删除：**在 n 个元素的顺序表中，将第 i（i <= n）个元素删除。其时间复杂度为 O<sub>(n)</sub>。
  - 方法：运算需要将从 a<sub>i+1</sub>到 a<sub>n</sub> ，共 n + i 个元素向上移动一个位置
    - 删除：把被删除元素存放到 x（x = 被删除元素）
    - 元素前移：把位置 j 后元素移动到位置 j +-1（赋值实现，位置 j - 1 = 位置 j 的元素）

  - 补充：顺序表中<font color="red">任意位置**删除**一个元素</font>的操作，<font color="red">平均移动元素次数为 **n  - 1 / 2**</font>

- **查找（按值顺序查找）：**在 n 个元素的顺序表中查找值为 x 的元素。其时间复杂度为 O<sub>(n)</sub> 。
  - 方法：运算主要是<font color="red">比较</font>，比较次数与 x 在表中的位置有关，也与表的长度有关


#### 5）顺序表的优缺点

- 优点：随机存取
- 缺点：不利于元素的插入和删除



<br>





### 3、<a id="A chain representation of a linear table">线性表的链式表示</a>

#### 1）单链表概念

##### （1）单链表的定义：线性表的链式存储又称单链表。指通过一组<font color="red">任意的存储单元（无需连续存储单元）</font>来存储线性表中的数据元素，而且线性的逻辑关系由每个元素附加的<font color="red">指针</font>指向来反映。

##### （2）单链表的节点  | data | next|

- data ：数据域，用于存放元素

- next ：指针域，用于存放后继节点的地址，这样就可以通过前驱点中的地址信息找到后继节点的位置

- 补充：

  - **头指针**：用来标识一个单链表
    - 头指针为空时则表示一个空表

  - **头结点**：在单链表第一个结点之前附加一个 “头结点”，头结点的数据域可以不设任何信息，头结点的指针域指向线性表的第一个结点
  - **首元结点**：线性表中的第一个元素

##### （3）链表增加头结点的作用

- 便于首元结点的处理
  - 增加了头结点之后，首元结点的地址保持在头结点的指针域中，则对链表的第一个数据元素的操作与元素相同，无需进行特殊处理
- 便于空表和非空表的统一处理
  - 增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针

##### （4）带头结点的单链表

- 课本有图

- 头结点的地址：L
- 头结点的指针（域）：L—>next
  - 指针（域）都能表示为：地址—>next
- a<sub>1</sub>的地址：L—>next
- a<sub>1</sub>的指针：L—>next—>next

##### （5）单链表的判空条件

- 不带头结点：L—>null			L==null
- 带头结点：L—>头结点—>null 		L—>next == null

##### （6）单链表的特点

- <font color="red">链表中结点的存储空间利用率比顺序表稍微低一些</font>（链表中的每一个结点需要划出一部分空间来存储指向下一结点位置的指针）
- <font color="red">链表的结点可以散落在内存中的任意位置，且不需要一次性的划分所有节点所需要的空间给链表，而是需要几个结点就临时划分几个</font>（链表中当前结点的位置是由前驱结点中的地址信息所指示的，而不是其相对与初始位置的偏移量来确定）
- 链表支持存储空间的动态分配
- 存储密度低（ 存储密度 = 元素大小 / 结点大小 ）
- 利于元素的插入和删除

 

#### 2）单链表的基本操作

##### （1）建立

- 头插法：头插法建立的单链表顺序和插入顺序相反，时间复杂度为O<sub>n</sub> 。
- 尾插法：头插法建立的单链表顺序和插入顺序相同，时间复杂度为O<sub>n</sub> 。

##### （2）插入

- 1、连接 x 和 B（改变 x 的指针）
  - 把 B 的地址存放到 x 的指针域（x 的指针域 = B 的地址）
- 2、连接 A 和 x（改变 A 的指针）
  - 把 x 的地址存放到 A 的指针域（A 的指针域 = x 的地址）

##### （3）删除     

##### （4）查询

- 按值查找
- 按位置查 找



